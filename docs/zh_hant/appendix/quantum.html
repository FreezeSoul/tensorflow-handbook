

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>TensorFlow Quantum: 混合量子-經典機器學習 * &mdash; 简单粗暴 TensorFlow 2 0.4 beta 文档</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/js/tw_cn.js"></script>
        <script src="../../_static/js/pangu.min.js"></script>
        <script src="../../_static/js/custom_20200921.js"></script>
        <script src="../../_static/translations.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/custom.css" type="text/css" />
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="強化學習簡介" href="rl.html" />
    <link rel="prev" title="Swift for TensorFlow (S4TF) (Huan）" href="swift.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> 简单粗暴 TensorFlow 2
          

          
          </a>

          
            
            
              <div class="version">
                0.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">目录</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../zh_hans/foreword.html">推荐序</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../zh_hans/preface.html">前言</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../zh_hans/introduction.html">TensorFlow概述</a></li>
</ul>
<p class="caption"><span class="caption-text">基础</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../zh_hans/basic/installation.html">TensorFlow安装与环境配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../zh_hans/basic/basic.html">TensorFlow基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../zh_hans/basic/models.html">TensorFlow 模型建立与训练</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../zh_hans/basic/tools.html">TensorFlow常用模块</a></li>
</ul>
<p class="caption"><span class="caption-text">部署</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../zh_hans/deployment/export.html">TensorFlow模型导出</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../zh_hans/deployment/serving.html">TensorFlow Serving</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../zh_hans/deployment/lite.html">TensorFlow Lite（Jinpeng）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../zh_hans/deployment/javascript.html">TensorFlow in JavaScript（Huan）</a></li>
</ul>
<p class="caption"><span class="caption-text">大规模训练与加速</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../zh_hans/appendix/distributed.html">TensorFlow分布式训练</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../zh_hans/appendix/tpu.html">使用TPU训练TensorFlow模型（Huan）</a></li>
</ul>
<p class="caption"><span class="caption-text">扩展</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../zh_hans/appendix/tfhub.html">TensorFlow Hub 模型复用（Jinpeng）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../zh_hans/appendix/tfds.html">TensorFlow Datasets 数据集载入</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../zh_hans/appendix/swift.html">Swift for TensorFlow (S4TF) (Huan）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../zh_hans/appendix/quantum.html">TensorFlow Quantum: 混合量子-经典机器学习 *</a></li>
</ul>
<p class="caption"><span class="caption-text">附录</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../zh_hans/appendix/rl.html">强化学习简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../zh_hans/appendix/docker.html">使用Docker部署TensorFlow环境</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../zh_hans/appendix/cloud.html">在云端使用TensorFlow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../zh_hans/appendix/jupyterlab.html">部署自己的交互式Python开发环境JupyterLab</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../zh_hans/appendix/recommended_books.html">参考资料与推荐阅读</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../zh_hans/appendix/terms.html">术语中英对照表</a></li>
</ul>
<p class="caption"><span class="caption-text">目錄</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../preface.html">前言</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">TensorFlow概述</a></li>
</ul>
<p class="caption"><span class="caption-text">基礎</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../basic/installation.html">TensorFlow 安裝與環境配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../basic/basic.html">TensorFlow 基礎</a></li>
<li class="toctree-l1"><a class="reference internal" href="../basic/models.html">TensorFlow 模型建立與訓練</a></li>
<li class="toctree-l1"><a class="reference internal" href="../basic/tools.html">TensorFlow常用模組</a></li>
</ul>
<p class="caption"><span class="caption-text">部署</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../deployment/export.html">TensorFlow模型匯出</a></li>
<li class="toctree-l1"><a class="reference internal" href="../deployment/serving.html">TensorFlow Serving</a></li>
<li class="toctree-l1"><a class="reference internal" href="../deployment/lite.html">TensorFlow Lite（Jinpeng）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../deployment/javascript.html">TensorFlow in JavaScript（Huan）</a></li>
</ul>
<p class="caption"><span class="caption-text">大規模訓練與加速</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="distributed.html">TensorFlow分布式訓練</a></li>
<li class="toctree-l1"><a class="reference internal" href="tpu.html">使用TPU訓練TensorFlow模型（Huan）</a></li>
</ul>
<p class="caption"><span class="caption-text">擴展</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="tfhub.html">TensorFlow Hub 模型複用（Jinpeng）</a></li>
<li class="toctree-l1"><a class="reference internal" href="tfds.html">TensorFlow Datasets 資料集載入</a></li>
<li class="toctree-l1"><a class="reference internal" href="swift.html">Swift for TensorFlow (S4TF) (Huan）</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">TensorFlow Quantum: 混合量子-經典機器學習 *</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">量子計算基本概念</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">量子位元</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">量子邏輯閘</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">量子電路</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cirq">實例：使用Cirq建立簡單的量子電路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id10">混合量子-經典機器學習</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id11">量子資料集與包含參數的量子閘</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pqc">參數化的量子電路（PQC）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">將參數化的量子電路嵌入機器學習模型</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id13">範例：對量子資料集進行二分類</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">附錄</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="rl.html">強化學習簡介</a></li>
<li class="toctree-l1"><a class="reference internal" href="docker.html">使用Docker部署TensorFlow環境</a></li>
<li class="toctree-l1"><a class="reference internal" href="cloud.html">在雲端使用TensorFlow</a></li>
<li class="toctree-l1"><a class="reference internal" href="jupyterlab.html">部署自己的互動式 Python 開發環境 JupyterLab</a></li>
<li class="toctree-l1"><a class="reference internal" href="recommended_books.html">參考資料與推薦閱讀</a></li>
<li class="toctree-l1"><a class="reference internal" href="terms.html">專有名詞中英對照表</a></li>
</ul>
<p class="caption"><span class="caption-text">Preface</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../en/preface.html">Preface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../en/introduction.html">TensorFlow Overview</a></li>
</ul>
<p class="caption"><span class="caption-text">Basic</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../en/basic/installation.html">Installation and Environment Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../en/basic/basic.html">TensorFlow Basic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../en/basic/models.html">Model Construction and Training</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../en/basic/tools.html">Common Modules in TensorFlow</a></li>
</ul>
<p class="caption"><span class="caption-text">Deployment</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../en/deployment/export.html">TensorFlow Model Export</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../en/deployment/serving.html">TensorFlow Serving</a></li>
</ul>
<p class="caption"><span class="caption-text">Large-scale Training</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../en/appendix/distributed.html">Distributed training with TensorFlow</a></li>
</ul>
<p class="caption"><span class="caption-text">Extensions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../en/appendix/tfds.html">TensorFlow Datasets: Ready-to-use Datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../en/appendix/quantum.html">TensorFlow Quantum: Hybrid Quantum-classical Machine Learning *</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">简单粗暴 TensorFlow 2</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
      <li>TensorFlow Quantum: 混合量子-經典機器學習 *</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/zh_hant/appendix/quantum.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="tensorflow-quantum">
<h1>TensorFlow Quantum: 混合量子-經典機器學習 *<a class="headerlink" href="#tensorflow-quantum" title="永久链接至标题">¶</a></h1>
<p>我們身邊的經典電腦利用位元和邏輯閘進行二進制運算。在物理硬體上，這種運算主要是通過半導體的特殊導電性質來實現。經過幾十年的發展，我們已經可以在一片小小的半導體晶片上有上億個晶體管，從而實現高性能的經典計算。</p>
<p>而量子計算（Quantum Computing）利用具有量子特性（例如量子疊加態和量子糾纏）的 “量子位元” 和 “量子閘” 進行計算。這種新的計算模式可以在搜索和大數分解等重要領域達成指數級的加速，讓當前無法實現的一些超大規模運算成為可能，在未來深遠的改變世界。在物理硬體上，這類量子運算也可以通過一些具有量子特性的結構（例如超導約瑟夫森結）來實現。</p>
<p>不幸的是，盡管量子計算的理論已經有了比較深入的發展，但在硬體上，我們目前仍然造不出一台超越經典電腦的通用量子電腦 1 。IBM 和谷歌等業界巨頭在通用量子電腦的物理構建上已經有一些不錯的成果，但無論是量子位元的個數還是在量子去相干問題的解決上，都還遠無法達到實用的層級。</p>
<p>以上是量子計算的基本背景，接下來我們討論量子機器學習。量子機器學習的一種最直接的思路是使用量子計算加速傳統的機器學習任務，例如量子版本的 PCA、SVM 和 K-Means 算法，然而這些算法目前都尚未達到可實用的程度。我們在本章討論的量子機器學習則朝向另一個思考方向，即建構參數化的量子電路（Parameterized Quantum Circuits, PQCs）。PQC 可以使用在深度學習模型中的層，如果我們在普通深度學習模型的基礎上加入 PQC，即稱為混合量子 - 經典機器學習（Hybrid Quantum-Classical Machine Learning）。這種混合模型非常適合於量子資料集（Quantum Data）上的任務。而 TensorFlow Quantum 正是幫助我們構建這種混合量子 - 經典機器學習模型的利器。接下來，我們會對量子計算許多種的基本概念進行簡介，然後介紹使用 TensorFlow Quantum 和谷歌的量子計算函式庫 Cirq 構建 PQC、將 PQC 嵌入 Keras 模型、並在量子資料集上訓練混合模型的流程。</p>
<div class="section" id="id1">
<h2>量子計算基本概念<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>本節將簡述量子計算的一些基本概念，包括量子位元、量子閘、量子電路等。</p>
<div class="admonition- admonition">
<p class="admonition-title">推薦閱讀</p>
<p>如果你希望更深入的了解量子力學以及量子計算的基本原理，建議可以從以下資源學習：</p>
<ul class="simple">
<li><p>Griffiths, D., &amp; Schroeter, D. (2018). <a class="reference external" href="https://www.cambridge.org/core/books/introduction-to-quantum-mechanics/990799CA07A83FC5312402AF6860311E">Introduction to Quantum Mechanics</a> . Cambridge: Cambridge University Press. doi:10.1017/9781316995433</p></li>
<li><p>Hidary, Jack D. <a class="reference external" href="http://link.springer.com/10.1007/978-3-030-23922-0">Quantum Computing: An Applied Approach</a> . Cham: Springer International Publishing, 2019. <a class="reference external" href="https://doi.org/10.1007/978-3-030-23922-0">https://doi.org/10.1007/978-3-030-23922-0</a>. （注重程式碼實操的量子計算教程，GitHub 上有配套源碼： <a class="reference external" href="https://github.com/JackHidary/quantumcomputingbook">https://github.com/JackHidary/quantumcomputingbook</a> ）</p></li>
</ul>
</div>
<div class="section" id="id2">
<h3>量子位元<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>在二進制的經典電腦中，我們用位元（Bit，也稱 “位元”）作為資料儲存的基本單位，一個位元只有 0 或 1 兩種狀態。而在量子電腦中，我們使用量子位元（Quantum Bit, Qubit，也稱 “量子位元”）進行資料的表示。量子位元也有兩種基本狀態 <img class="math" src="../../_images/math/cf11c763ecfb6c354b67ca28eb9956b3d0197f55.png" alt="\ket{0}"/> 和 <img class="math" src="../../_images/math/1dc0cbd2935484e6c27e2bd6fdb89e3a2bee9a64.png" alt="\ket{1}"/> 。不過量子位元除了可以處於這兩種基本狀態以外，還可以處於兩者之間的疊加態（Superposition State），即 <img class="math" src="../../_images/math/cb62f6b814018e36a06acdc07ddd8de7ce8dafff.png" alt="\ket{\psi} = a \ket{0} + b \ket{1}"/> （其中a和b是複數， <img class="math" src="../../_images/math/fda8d4ed57f788a15760f0a1ec6f4d9d8618da47.png" alt="|a|^2 + |b|^2 = 1"/> ）。例如， <img class="math" src="../../_images/math/bc1c385e3ea3312c60790a3e4d5a2e071fd87d86.png" alt="\ket{\psi_0} = \frac{1}{\sqrt{2}} \ket{0} + \frac{1}{\sqrt{2}} \ket{1}"/> 和 <img class="math" src="../../_images/math/7a38874696965458beef81b0fd6fd77563b23f4a.png" alt="\ket{\psi_1} = \frac{1}{\sqrt{2}} \ket{0} - \frac{1}{\sqrt{2}} \ket{1}"/> 都是合法的量子狀態。我們也可以使用向量化的語言來表示量子位元的狀態。如果我們令 <img class="math" src="../../_images/math/d9f442b006c94ee9fe33ac7dafbf2327de02766c.png" alt="\ket{0} = \begin{bmatrix}1 \\ 0\end{bmatrix}"/> 、 <img class="math" src="../../_images/math/cba07e3f03a49c4ba86c24422818fc9f760d39fe.png" alt="\ket{1} = \begin{bmatrix}0 \\ 1\end{bmatrix}"/>，則 <img class="math" src="../../_images/math/79e8eeae52eee88a430880991a1ca27fda15ae20.png" alt="\ket{\psi} = \begin{bmatrix}a \\ b\end{bmatrix}"/>、<img class="math" src="../../_images/math/eeb8a3ed29efa47f00add692157497f2b12d7867.png" alt="\ket{\psi_0} = \begin{bmatrix}\frac{1}{\sqrt{2}} \\ \frac{1}{\sqrt{2}}\end{bmatrix}"/>、<img class="math" src="../../_images/math/8f9f2482a0167f20c12406c60a6446ae81bc73c5.png" alt="\ket{\psi_1} = \begin{bmatrix}\frac{1}{\sqrt{2}} \\ -\frac{1}{\sqrt{2}}\end{bmatrix}"/>。</p>
<p>同時，我們可以用布洛赫球面（Bloch Sphere）來展示單個量子位元的狀態。球面的最頂端為 <img class="math" src="../../_images/math/cf11c763ecfb6c354b67ca28eb9956b3d0197f55.png" alt="\ket{0}"/> ，最底端為 <img class="math" src="../../_images/math/1dc0cbd2935484e6c27e2bd6fdb89e3a2bee9a64.png" alt="\ket{1}"/> ，而從原點到球面上任何一點的單位向量都可以是一個量子位元的狀態。</p>
<div class="figure align-center" id="id14">
<a class="reference internal image-reference" href="../../_images/bloch_sphere.png"><img alt="../../_images/bloch_sphere.png" src="../../_images/bloch_sphere.png" style="width: 30%;" /></a>
<p class="caption"><span class="caption-text">布洛赫球面（ <a class="reference external" href="https://en.wikipedia.org/wiki/Bloch_sphere">Bloch Sphere</a> ）。其中Z軸正負方向的量子態分別爲基本態 <img class="math" src="../../_images/math/cf11c763ecfb6c354b67ca28eb9956b3d0197f55.png" alt="\ket{0}"/> 和 <img class="math" src="../../_images/math/1dc0cbd2935484e6c27e2bd6fdb89e3a2bee9a64.png" alt="\ket{1}"/> ，X軸正負方向的量子態分別爲 <img class="math" src="../../_images/math/984c19e665faa644fe597e3133d6613b0e244dfc.png" alt="\frac{1}{\sqrt{2}} \ket{0} + \frac{1}{\sqrt{2}} \ket{1}"/> 和 <img class="math" src="../../_images/math/a4287cbdb7bef180904db655abff5184369a6649.png" alt="\frac{1}{\sqrt{2}} \ket{0} - \frac{1}{\sqrt{2}} \ket{1}"/> ，Y軸正負方向的量子態分別爲 <img class="math" src="../../_images/math/fe079eca300639ddd5ae8355b4092956a1abeb15.png" alt="\frac{1}{\sqrt{2}} \ket{0} + \frac{i}{\sqrt{2}} \ket{1}"/> 和 <img class="math" src="../../_images/math/410a3fc002b2696af098f0c455e56bddf98a6330.png" alt="\frac{1}{\sqrt{2}} \ket{0} - \frac{i}{\sqrt{2}} \ket{1}"/> 。<a class="reference external" href="https://en.wikipedia.org/wiki/File:Bloch_sphere.svg">圖示來源</a></span><a class="headerlink" href="#id14" title="永久链接至图片">¶</a></p>
</div>
<p>值得特別注意的是，儘管量子位元 <img class="math" src="../../_images/math/cb62f6b814018e36a06acdc07ddd8de7ce8dafff.png" alt="\ket{\psi} = a \ket{0} + b \ket{1}"/> 可能的狀態相當之多，但一旦我們對其進行觀測，則其狀態會立即坍縮 <a class="footnote-reference brackets" href="#f1" id="id4">2</a> 到 <img class="math" src="../../_images/math/cf11c763ecfb6c354b67ca28eb9956b3d0197f55.png" alt="\ket{0}"/> 和 <img class="math" src="../../_images/math/1dc0cbd2935484e6c27e2bd6fdb89e3a2bee9a64.png" alt="\ket{1}"/> 這兩個基本狀態中的一個，其概率分別爲 <img class="math" src="../../_images/math/ac5498723d4e8d9267643ab25e38bae3e9f87881.png" alt="|a|^2"/> 和  <img class="math" src="../../_images/math/f85ee1a43dbb809cf8e29f521a63aa72b3a2f827.png" alt="|b|^2"/> 。</p>
</div>
<div class="section" id="id5">
<h3>量子邏輯閘<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>在二進制的經典電腦中，我們有 AND、OR、NOT等邏輯閘，對輸入的位元狀態進行變換並輸出。在量子電腦中，我們同樣有量子邏輯閘（Quantum Logic Gate，或簡稱 “量子閘”），對量子狀態進行變換並輸出。如果我們使用向量化的語言來表述量子狀態，則量子邏輯閘可以看作是一個對狀態向量進行變換的矩陣。</p>
<p>例如，量子NOT閘可以表達成 <img class="math" src="../../_images/math/3080bb728f567f066f0c7c43aa9404bafd0cd30c.png" alt="X = \begin{bmatrix}0 &amp; 1 \\ 1 &amp; 0\end{bmatrix}"/> ，於是當我們將量子NOT閘作用於基本態  <img class="math" src="../../_images/math/d9f442b006c94ee9fe33ac7dafbf2327de02766c.png" alt="\ket{0} = \begin{bmatrix}1 \\ 0\end{bmatrix}"/> 時，我們得到 <img class="math" src="../../_images/math/18736cd13eb2f4d86467e9f9e52eca39fd2f517d.png" alt="X\ket{0} = \begin{bmatrix}0 &amp; 1 \\ 1 &amp; 0\end{bmatrix} \begin{bmatrix}1 \\ 0\end{bmatrix} = \begin{bmatrix}0 \\ 1\end{bmatrix} = \ket{1}"/>。量子閘也可以作用在疊加態，例如 <img class="math" src="../../_images/math/9b1eaaa3834ce9f5ce9c52272d75c9c8fce0895b.png" alt="X\ket{\psi_0} = \begin{bmatrix}0 &amp; 1 \\ 1 &amp; 0\end{bmatrix} \begin{bmatrix}\frac{1}{\sqrt{2}} \\ \frac{1}{\sqrt{2}}\end{bmatrix} = \begin{bmatrix}\frac{1}{\sqrt{2}} \\ \frac{1}{\sqrt{2}}\end{bmatrix} = \ket{\psi_0}"/> （這說明量子NOT閘沒能改變量子態 <img class="math" src="../../_images/math/bc1c385e3ea3312c60790a3e4d5a2e071fd87d86.png" alt="\ket{\psi_0} = \frac{1}{\sqrt{2}} \ket{0} + \frac{1}{\sqrt{2}} \ket{1}"/> 的狀態。事實上，量子NOT閘 <img class="math" src="../../_images/math/ded54539a996e559133ad16363d76c51fc8d87e7.png" alt="X"/> 相當於在布洛赫球面上將量子態繞X軸旋轉180度。而 <img class="math" src="../../_images/math/1af1b7de7f38ea0f40b9954bce778c4c8468c33a.png" alt="\ket{\psi_0}"/> 就在X軸上，所以沒有變化）。量子AND閘和OR閘 <a class="footnote-reference brackets" href="#f2" id="id6">3</a> 由於涉及到多個量子位元而稍顯複雜，但同樣可以通過尺寸更大的矩陣實現。</p>
<p>可能有些讀者已經想到了，既然單個量子位元的狀態不止 <img class="math" src="../../_images/math/cf11c763ecfb6c354b67ca28eb9956b3d0197f55.png" alt="\ket{0}"/> 和 <img class="math" src="../../_images/math/1dc0cbd2935484e6c27e2bd6fdb89e3a2bee9a64.png" alt="\ket{1}"/> 兩種，那麼量子邏輯閘作為作為對量子位元的變換，其實也完全可以不局限於AND或NOT。事實上，只要滿足一定條件的矩陣 <a class="footnote-reference brackets" href="#f3" id="id7">4</a> 都可以作為量子邏輯閘。例如，將量子態在布洛赫球面上繞 X、Y、Z 軸旋轉的變換:math:<cite>Rx(theta)</cite> 、<img class="math" src="../../_images/math/d07d1cc4c66a121e4da2247a4e24a1c31a7115cc.png" alt="Ry(\theta)"/> 、<img class="math" src="../../_images/math/bae48849043d944e70c7fd069ab84b295b385b6d.png" alt="Rz(\theta)"/> （其中 <img class="math" src="../../_images/math/bec204813d5e9097a453e6a6dfbe0409dc177ff8.png" alt="\theta"/> 是旋轉角度，當 <img class="math" src="../../_images/math/788c2c7d03643cff00033641c84342eb48e978ea.png" alt="\theta=180^\circ"/> 時記爲 <img class="math" src="../../_images/math/ded54539a996e559133ad16363d76c51fc8d87e7.png" alt="X"/> 、<img class="math" src="../../_images/math/f89383d07ea00637c4218cd6dc4eb3ae2b04fcdc.png" alt="Y"/> 、<img class="math" src="../../_images/math/1bf0276de4a07346e2f468d40a0cec0ea489a6e0.png" alt="Z"/> ）都是量子邏輯閘。另外，有一個量子邏輯閘「阿達馬閘」（Hadamard Gate） <img class="math" src="../../_images/math/fbc0ab4c252c720edfc9469add4d9828dc93abb1.png" alt="H = \frac{1}{\sqrt{2}} \begin{bmatrix}1 &amp; 1 \\ 1 &amp; -1\end{bmatrix}"/> 可以將量子狀態從基本態轉換爲疊加態，在很多量子計算的場景中占據了重要地位。</p>
</div>
<div class="section" id="id8">
<h3>量子電路<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<p>當我們將量子位元以及量子邏輯閘按順序標記在一條或多條平行的線條上時，就構成了量子電路（Quantum Circuit，或稱量子電路）。例如，對於我們在上一節討論的，使用量子NOT閘 <img class="math" src="../../_images/math/ded54539a996e559133ad16363d76c51fc8d87e7.png" alt="X"/> 對基本態 <img class="math" src="../../_images/math/cf11c763ecfb6c354b67ca28eb9956b3d0197f55.png" alt="\ket{0}"/> 進行變換的過程，我們可以寫出量子電路如下：</p>
<div class="figure align-center" id="id15">
<a class="reference internal image-reference" href="../../_images/X_circuit.png"><img alt="../../_images/X_circuit.png" src="../../_images/X_circuit.png" style="width: 30%;" /></a>
<p class="caption"><span class="caption-text">一個簡單的量子電路</span><a class="headerlink" href="#id15" title="永久链接至图片">¶</a></p>
</div>
<p>在量子電路中，每條橫線代表一個量子位元。上圖中最左邊的 <img class="math" src="../../_images/math/cf11c763ecfb6c354b67ca28eb9956b3d0197f55.png" alt="\ket{0}"/> 代表量子位元的初始態。中間的X方塊代表量子NOT閘 <img class="math" src="../../_images/math/ded54539a996e559133ad16363d76c51fc8d87e7.png" alt="X"/> ，最右邊的錶盤符號代表測量操作。這個電路的意義是「對初始狀態爲 <img class="math" src="../../_images/math/cf11c763ecfb6c354b67ca28eb9956b3d0197f55.png" alt="\ket{0}"/> 的量子位元執行量子NOT閘 <img class="math" src="../../_images/math/ded54539a996e559133ad16363d76c51fc8d87e7.png" alt="X"/> 操作，並測量變換後的量子位元狀態」。根據我們在前面章節的討論，變換後的量子位元狀態為基本態  <img class="math" src="../../_images/math/1dc0cbd2935484e6c27e2bd6fdb89e3a2bee9a64.png" alt="\ket{1}"/> ，因此我們可以期待該量子電路最後的測量結果始終為 1。</p>
<p>接下來，我們考慮將上圖中量子電路的量子NOT閘 <img class="math" src="../../_images/math/ded54539a996e559133ad16363d76c51fc8d87e7.png" alt="X"/> 換爲阿達馬閘 <img class="math" src="../../_images/math/aaf3132d08f6d8d7a2be379482c0f2c5f93118f5.png" alt="H"/> ：</p>
<div class="figure align-center" id="id16">
<a class="reference internal image-reference" href="../../_images/H_circuit.png"><img alt="../../_images/H_circuit.png" src="../../_images/H_circuit.png" style="width: 30%;" /></a>
<p class="caption"><span class="caption-text">將量子NOT閘 <img class="math" src="../../_images/math/ded54539a996e559133ad16363d76c51fc8d87e7.png" alt="X"/> 換爲阿達馬閘 <img class="math" src="../../_images/math/aaf3132d08f6d8d7a2be379482c0f2c5f93118f5.png" alt="H"/> 後的量子電路</span><a class="headerlink" href="#id16" title="永久链接至图片">¶</a></p>
</div>
<p>阿達馬閘(Hadamard gate)對應的矩陣表示為 <img class="math" src="../../_images/math/fbc0ab4c252c720edfc9469add4d9828dc93abb1.png" alt="H = \frac{1}{\sqrt{2}} \begin{bmatrix}1 &amp; 1 \\ 1 &amp; -1\end{bmatrix}"/> ，於是我們可以計算出變換後的量子態為 <img class="math" src="../../_images/math/e54197a85a7fed22dbac9b4fe02c3875dc2530cd.png" alt="H\ket{0} = \frac{1}{\sqrt{2}} \begin{bmatrix}1 &amp; 1 \\ 1 &amp; -1\end{bmatrix}\begin{bmatrix}1 \\ 0\end{bmatrix} = \begin{bmatrix}\frac{1}{\sqrt{2}} \\ \frac{1}{\sqrt{2}}\end{bmatrix} = \frac{1}{\sqrt{2}} \ket{0} + \frac{1}{\sqrt{2}} \ket{1}"/> 。這是一個 <img class="math" src="../../_images/math/cf11c763ecfb6c354b67ca28eb9956b3d0197f55.png" alt="\ket{0}"/> 和 <img class="math" src="../../_images/math/1dc0cbd2935484e6c27e2bd6fdb89e3a2bee9a64.png" alt="\ket{1}"/> 的疊加態，在觀測後會坍縮(Collapse)到基本態，其機率分別為 <img class="math" src="../../_images/math/991df5fe1973ab13f4ae55c33ba569fb8f378307.png" alt="|\frac{1}{\sqrt{2}}|^2 = \frac{1}{2}"/> 。也就是說，這個量子電路的觀測結果類似於扔硬幣。假若觀測 20 次，則大約 10 次的結果是 <img class="math" src="../../_images/math/cf11c763ecfb6c354b67ca28eb9956b3d0197f55.png" alt="\ket{0}"/> ，10次的結果是 <img class="math" src="../../_images/math/1dc0cbd2935484e6c27e2bd6fdb89e3a2bee9a64.png" alt="\ket{1}"/> 。</p>
</div>
<div class="section" id="cirq">
<h3>實例：使用Cirq建立簡單的量子電路<a class="headerlink" href="#cirq" title="永久链接至标题">¶</a></h3>
<p><a class="reference external" href="https://cirq.readthedocs.io/">Cirq</a> 是谷歌主導的開源量子計算函式庫，可以幫助我們方便的建立量子電路並模擬測量結果（我們在下一節介紹 TensorFlow Quantum 的時候還會用到它）。Cirq 是一個 Python 函式庫，可以使用 <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">cirq</span></code> 進行安裝。以下程式碼實現了上一個章節所建立的兩個簡單的量子電路，並分別進行了 20 次的模擬測量。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cirq</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">LineQubit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>           <span class="c1"># 實例化一個量子位元</span>
<span class="n">simulator</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">Simulator</span><span class="p">()</span>    <span class="c1"># 實例化一個模擬器</span>

<span class="n">X_circuit</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span>       <span class="c1"># 建立一個包含量子NOT閘和測量的量子電路</span>
    <span class="n">cirq</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="n">q</span><span class="p">),</span>
    <span class="n">cirq</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">X_circuit</span><span class="p">)</span>                <span class="c1"># 在終端可視化輸出量子電路</span>

<span class="c1"># 使用模擬器對該量子電路進行20次的模擬測量</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">simulator</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">X_circuit</span><span class="p">,</span> <span class="n">repetitions</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>                   <span class="c1"># 輸出模擬測量結果</span>

<span class="n">H_circuit</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span>       <span class="c1"># 建立一個包含阿達馬閘和測量的量子電路</span>
    <span class="n">cirq</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="n">q</span><span class="p">),</span>
    <span class="n">cirq</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">H_circuit</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">simulator</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">H_circuit</span><span class="p">,</span> <span class="n">repetitions</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>結果如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>0: ───X───M───
0=11111111111111111111
0: ───H───M───
0=00100111001111101100
</pre></div>
</div>
<p>可見第一個量子電路的測量結果始終為 1，第二個量子態的 20 次測量結果中有 9 次是 0，11 次是 1（如果你多運行幾次，會發現 0 和 1 出現的機率趨近於 <img class="math" src="../../_images/math/71c8247661268e91ff882cb0fd09811ac9e3317f.png" alt="\frac{1}{2}"/> ）。可見結果符合我們在上節中的分析。</p>
</div>
</div>
<div class="section" id="id10">
<h2>混合量子-經典機器學習<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h2>
<p>本節介紹混合量子 - 經典機器學習的基本概念，以及使用 TensorFlow Quantum 建立此類模型的方法。</p>
<p>在混合量子 - 經典機器學習過程中，我們使用量子資料集訓練混合量子 - 經典模型。混合量子 - 經典模型的前半部分是量子模型（即參數化的量子電路）。量子模型接受量子資料集作為輸入，對輸入使用量子閘進行變換，然後通過測量轉換為經典資料。測量後的經典資料輸入經典模型，並使用常規的損失函數計算模型的損失值。最後，基於損失函數的值計算模型參數的梯度並更新模型參數。整個過程不僅包括經典模型的參數，也包括量子模型的參數。具體流程如下圖所示。</p>
<div class="figure align-center" id="id17">
<a class="reference internal image-reference" href="../../_images/pipeline_ch.png"><img alt="../../_images/pipeline_ch.png" src="../../_images/pipeline_ch.png" style="width: 60%;" /></a>
<p class="caption"><span class="caption-text">經典機器學習（上圖）與混合量子-經典機器學習（下圖）的流程對比</span><a class="headerlink" href="#id17" title="永久链接至图片">¶</a></p>
</div>
<p>TensorFlow Quantum 即是一個與 TensorFlow Keras 結合緊密的，可快速建立混合量子 - 經典機器學習模型的開源函式庫，可以使用 <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">tensorflow-quantum</span></code> 進行安裝。</p>
<p>後文範例默認使用以下程式碼導入 TensorFlow、TensorFlow Quantum 和 Cirq：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">tensorflow</span> <span class="kn">as</span> <span class="nn">tf</span>
<span class="kn">import</span> <span class="nn">tensorflow_quantum</span> <span class="kn">as</span> <span class="nn">tfq</span>
<span class="kn">import</span> <span class="nn">cirq</span>
</pre></div>
</div>
<div class="admonition- admonition">
<p class="admonition-title">推薦閱讀</p>
<p>Broughton, Michael, Guillaume Verdon, Trevor McCourt, Antonio J. Martinez, Jae Hyeon Yoo, Sergei V. Isakov, Philip Massey, et al. 「 <a class="reference external" href="http://arxiv.org/abs/2003.02989">TensorFlow Quantum: A Software Framework for Quantum Machine Learning.</a> 」 ArXiv:2003.02989 [Cond-Mat, Physics:Quant-Ph], March 5, 2020. （TensorFlow Quantum 白皮書）</p>
</div>
<div class="section" id="id11">
<h3>量子資料集與包含參數的量子閘<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
<p>監督式學習為例，資料集由資料和標籤組成。資料中的每一項是一個由不同特徵組成的向量。我們可以將資料集寫作 <img class="math" src="../../_images/math/096f91ff12dd51c06b36fc1ec37d3af7268a2f8e.png" alt="(x_1, y_1), (x_2, y_2), \cdots, (x_N, y_N)"/> ，其中 <img class="math" src="../../_images/math/251ea575b8852ce126d702e86ad5941495fe1104.png" alt="x_i = (x_{i,1}, \cdots, x_{i,K})"/> 。量子資料集同樣由資料和標籤組成，而資料中的每一項是一個量子態。以前面章節單量子位元的量子態為例，我們可以將每一項資料寫作  <img class="math" src="../../_images/math/ee337198a1d125f7fd60f4006b7d3e9a6d6ef0aa.png" alt="x_i = a_i \ket{0} + b_i \ket{1}"/> 。在具體實現上，我們可以通過量子電路來生成量子資料。也就是說，每一項資料 <img class="math" src="../../_images/math/b0a60237087d130c0f2fb4d6325012dd5ae80fe1.png" alt="x_i"/> 都對應著一個量子電路。例如，我們可以通過以下程式碼，使用 Cirq 生成一組量子資料：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">GridQubit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">q_data</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">x_i</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span>
        <span class="n">cirq</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)(</span><span class="n">q</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">q_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_i</span><span class="p">)</span>
</pre></div>
</div>
<p>在這個過程中，我們使用了一個帶參數的量子閘 <code class="docutils literal notranslate"><span class="pre">cirq.rx(angle)(q)</span></code> 。和之前我們使用的量子閘 <code class="docutils literal notranslate"><span class="pre">cirq.X(q)</span></code> , <code class="docutils literal notranslate"><span class="pre">cirq.H(q)</span></code> 不同的是，這個量子閘多了一個參數 <code class="docutils literal notranslate"><span class="pre">angle</span></code> ，表示將量子位元 <code class="docutils literal notranslate"><span class="pre">q</span></code> 繞布洛赫球面的 x 軸旋轉 <code class="docutils literal notranslate"><span class="pre">angle</span></code> 角度。以上程式碼生成了 100 項量子資料，每項資料是從基本態 <img class="math" src="../../_images/math/cf11c763ecfb6c354b67ca28eb9956b3d0197f55.png" alt="\ket{0}"/> 開始繞布洛赫球面的x軸隨機旋轉 <img class="math" src="../../_images/math/b61438f8e15d426e93bf63b6c39c296435cdacaf.png" alt="[0, \pi]"/> 角度所變換而來的量子態。量子資料集在不少量子相關的領域（如化學、材料科學、生物學和藥物發現等）都有應用。</p>
<p>當我們要將量子資料集作為 Keras 的輸入時，可以使用 TensorFlow Quantum 的 <code class="docutils literal notranslate"><span class="pre">convert_to_tensor</span></code> 方法，將量子資料集轉換為張量：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">q_data</span> <span class="o">=</span> <span class="n">tfq</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">q_data</span><span class="p">)</span>
</pre></div>
</div>
<p>值得注意的是，當使用量子資料集作為 Keras 模型的訓練資料時，Keras 模型的輸入類型（ <code class="docutils literal notranslate"><span class="pre">dtype</span></code> ）需要為 <code class="docutils literal notranslate"><span class="pre">tf.dtypes.string</span></code> 。</p>
</div>
<div class="section" id="pqc">
<h3>參數化的量子電路（PQC）<a class="headerlink" href="#pqc" title="永久链接至标题">¶</a></h3>
<p>當我們在建立量子電路時使用了帶參數的量子閘，該參數可以自由調整，我們稱這樣的量子電路為參數化的量子電路。Cirq 支持結合 SymPy 這一 Python 下的符號運算函式庫實現參數化的量子電路，範例如下</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sympy</span>
<span class="n">theta</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;theta&#39;</span><span class="p">)</span>
<span class="n">q_model</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="n">cirq</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">theta</span><span class="p">)(</span><span class="n">q</span><span class="p">))</span>
</pre></div>
</div>
<p>在上面的程式碼中，我們建立了如下圖所示的量子電路。該量子電路可以將任意輸入量子態  <img class="math" src="../../_images/math/dc236aef0d575ac9f9dbaa2b8812801ee72f1b3a.png" alt="\ket{\psi}"/> 繞布洛赫球面的x軸逆時針旋轉 <img class="math" src="../../_images/math/bec204813d5e9097a453e6a6dfbe0409dc177ff8.png" alt="\theta"/> 度，其中 <img class="math" src="../../_images/math/bec204813d5e9097a453e6a6dfbe0409dc177ff8.png" alt="\theta"/> 是使用 <code class="docutils literal notranslate"><span class="pre">sympy.Symbol</span></code> 宣告的符號變數（即參數）。</p>
<div class="figure align-center" id="id18">
<a class="reference internal image-reference" href="../../_images/pqc.png"><img alt="../../_images/pqc.png" src="../../_images/pqc.png" style="width: 30%;" /></a>
<p class="caption"><span class="caption-text">參數化的量子電路範例</span><a class="headerlink" href="#id18" title="永久链接至图片">¶</a></p>
</div>
</div>
<div class="section" id="id12">
<h3>將參數化的量子電路嵌入機器學習模型<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h3>
<p>通過 TensorFlow Quantum，我們可以輕鬆的將參數化的量子電路以 Keras 層的方式嵌入 Keras 模型。例如前面章節建立的參數化的量子電路 <code class="docutils literal notranslate"><span class="pre">q_model</span></code> ，我們可以使用 <code class="docutils literal notranslate"><span class="pre">tfq.layers.PQC</span></code> 將其直接作為一個 Keras 層使用</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">q_layer</span> <span class="o">=</span> <span class="n">tfq</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">PQC</span><span class="p">(</span><span class="n">q_model</span><span class="p">,</span> <span class="n">cirq</span><span class="o">.</span><span class="n">Z</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
<span class="n">expectation_output</span> <span class="o">=</span> <span class="n">q_layer</span><span class="p">(</span><span class="n">q_data_input</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">tfq.layers.PQC</span></code> 的第一個參數為使用 Cirq 建立的參數化的量子電路，第二個參數為測量方式，此處使用 <code class="docutils literal notranslate"><span class="pre">cirq.Z(q)</span></code> 在布洛赫球面的 Z 軸進行測量。
以上程式碼也可直接寫作：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">expectation_output</span> <span class="o">=</span> <span class="n">tfq</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">PQC</span><span class="p">(</span><span class="n">q_model</span><span class="p">,</span> <span class="n">cirq</span><span class="o">.</span><span class="n">Z</span><span class="p">(</span><span class="n">q</span><span class="p">))(</span><span class="n">q_data_input</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id13">
<h3>範例：對量子資料集進行二分類<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h3>
<p>在以下程式碼中，我們首先建立了一個量子資料集，其中一半的資料為基本態 <img class="math" src="../../_images/math/cf11c763ecfb6c354b67ca28eb9956b3d0197f55.png" alt="\ket{0}"/> 繞布洛赫球面的x軸逆時針旋轉 <img class="math" src="../../_images/math/88a099a1a8abf9668c3f59d39cde820b58b82338.png" alt="\frac{\pi}{2}"/> 弧度（即 <img class="math" src="../../_images/math/410a3fc002b2696af098f0c455e56bddf98a6330.png" alt="\frac{1}{\sqrt{2}} \ket{0} - \frac{i}{\sqrt{2}} \ket{1}"/> ），另一半則為 <img class="math" src="../../_images/math/109839abe87d13d28bcb6d5fd7de624cfcd3247b.png" alt="\frac{3\pi}{2}"/> 弧度（即 <img class="math" src="../../_images/math/fe079eca300639ddd5ae8355b4092956a1abeb15.png" alt="\frac{1}{\sqrt{2}} \ket{0} + \frac{i}{\sqrt{2}} \ket{1}"/> ）。所有的資料均加入了繞 x,y 軸方向旋轉的，標準差為 <img class="math" src="../../_images/math/98f8e5bef3cfb82a97dc0ded3acbaaf41e00191d.png" alt="\frac{\pi}{4}"/> 的高斯噪聲。對於這個量子資料集，如果不加變換而直接測量，則所有資料都會和拋硬幣一樣等機率隨機坍縮到基本態 <img class="math" src="../../_images/math/cf11c763ecfb6c354b67ca28eb9956b3d0197f55.png" alt="\ket{0}"/> 和 <img class="math" src="../../_images/math/1dc0cbd2935484e6c27e2bd6fdb89e3a2bee9a64.png" alt="\ket{1}"/> ，從而無法區分。</p>
<p>為了區分這兩類資料，我們接下來建立了一個量子模型，這個模型將單位元量子態繞布洛赫球面的 x 軸逆時針旋轉  <img class="math" src="../../_images/math/bec204813d5e9097a453e6a6dfbe0409dc177ff8.png" alt="\theta"/> 角度。變換過後量子態資料的測量值送入 “全連接層 + softmax” 的經典機器學習模型，並使用交叉熵作為損失函數。模型訓練過程會自動同時調整量子模型中 <img class="math" src="../../_images/math/bec204813d5e9097a453e6a6dfbe0409dc177ff8.png" alt="\theta"/> 的值和全連接層的權重值，使得整個混合量子 - 經典機器學習模型的準確度較高。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cirq</span>
<span class="kn">import</span> <span class="nn">sympy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>
<span class="kn">import</span> <span class="nn">tensorflow_quantum</span> <span class="k">as</span> <span class="nn">tfq</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">GridQubit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1"># 準備量子資料集(q_data, label)</span>
<span class="n">add_noise</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="n">q_data</span> <span class="o">=</span> <span class="n">tfq</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span>
    <span class="p">[</span><span class="n">cirq</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span>
        <span class="n">cirq</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">add_noise</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))(</span><span class="n">q</span><span class="p">),</span> 
        <span class="n">cirq</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">add_noise</span><span class="p">(</span><span class="mi">0</span><span class="p">))(</span><span class="n">q</span><span class="p">)</span>
        <span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)]</span> <span class="o">+</span> 
    <span class="p">[</span><span class="n">cirq</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span>
        <span class="n">cirq</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">add_noise</span><span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))(</span><span class="n">q</span><span class="p">),</span> 
        <span class="n">cirq</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">add_noise</span><span class="p">(</span><span class="mi">0</span><span class="p">))(</span><span class="n">q</span><span class="p">)</span>
        <span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)]</span>
<span class="p">)</span>
<span class="n">label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>

<span class="c1"># 建立參數化的量子電路（PQC）</span>
<span class="n">theta</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;theta&#39;</span><span class="p">)</span>
<span class="n">q_model</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="n">cirq</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">theta</span><span class="p">)(</span><span class="n">q</span><span class="p">))</span>

<span class="c1"># 建立量子層和經典全連接層</span>
<span class="n">q_layer</span> <span class="o">=</span> <span class="n">tfq</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">PQC</span><span class="p">(</span><span class="n">q_model</span><span class="p">,</span> <span class="n">cirq</span><span class="o">.</span><span class="n">Z</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
<span class="n">dense_layer</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">activations</span><span class="o">.</span><span class="n">softmax</span><span class="p">)</span>

<span class="c1"># 使用Keras建立訓練流程。量子資料首先通過PQC，然後通過經典的全連接模型</span>
<span class="n">q_data_input</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">()</span> <span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">dtypes</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
<span class="n">expectation_output</span> <span class="o">=</span> <span class="n">q_layer</span><span class="p">(</span><span class="n">q_data_input</span><span class="p">)</span>
<span class="n">classifier_output</span> <span class="o">=</span> <span class="n">dense_layer</span><span class="p">(</span><span class="n">expectation_output</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="n">q_data_input</span><span class="p">,</span> <span class="n">outputs</span><span class="o">=</span><span class="n">classifier_output</span><span class="p">)</span>

<span class="c1"># 編譯模型，指定優化器、損失函數和評估指標，並進行訓練</span>
<span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
    <span class="n">optimizer</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">optimizers</span><span class="o">.</span><span class="n">SGD</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.01</span><span class="p">),</span>
    <span class="n">loss</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">losses</span><span class="o">.</span><span class="n">sparse_categorical_crossentropy</span><span class="p">,</span>
    <span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">metrics</span><span class="o">.</span><span class="n">sparse_categorical_accuracy</span><span class="p">]</span>
<span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">q_data</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>

<span class="c1"># 輸出量子層參數（即theta）的訓練結果</span>
<span class="nb">print</span><span class="p">(</span><span class="n">q_layer</span><span class="o">.</span><span class="n">get_weights</span><span class="p">())</span>
</pre></div>
</div>
<p>輸出：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="mi">200</span><span class="o">/</span><span class="mi">200</span> <span class="p">[</span><span class="o">==============================</span><span class="p">]</span> <span class="o">-</span> <span class="mi">0</span><span class="n">s</span> <span class="mi">165</span><span class="n">us</span><span class="o">/</span><span class="n">sample</span> <span class="o">-</span> <span class="n">loss</span><span class="p">:</span> <span class="mf">0.1586</span> <span class="o">-</span> <span class="n">sparse_categorical_accuracy</span><span class="p">:</span> <span class="mf">0.9500</span>
<span class="p">[</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.5279944</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float32</span><span class="p">)]</span>
</pre></div>
</div>
<p>可以發現，通過訓練，模型在訓練集上可以達到 95% 的準確率， <img class="math" src="../../_images/math/703b23c524f1af12c1c12deaedc67c5a8c513052.png" alt="\theta = -1.5279944 \approx -\frac{\pi}{2} = -1.5707963..."/> 。而當 <img class="math" src="../../_images/math/1ff979e6b4f47ffa5a7589539cb7211af74b5c26.png" alt="\theta = -\frac{\pi}{2}"/> 時，恰好可以使得兩種類型的資料分別接近基本態 <img class="math" src="../../_images/math/cf11c763ecfb6c354b67ca28eb9956b3d0197f55.png" alt="\ket{0}"/> 和 <img class="math" src="../../_images/math/1dc0cbd2935484e6c27e2bd6fdb89e3a2bee9a64.png" alt="\ket{1}"/> ，從而達到最易區分的狀態。</p>
<dl class="footnote brackets">
<dt class="label" id="f0"><span class="brackets">1</span></dt>
<dd><p>此手冊的發行時間為西元 2020 年，如果你來自未來，請理解作者的時代局限性。</p>
</dd>
<dt class="label" id="f1"><span class="brackets"><a class="fn-backref" href="#id4">2</a></span></dt>
<dd><p>“坍縮” 一詞多用於量子觀測的哥本哈根詮釋，除此以外還有多世界理論等。此處使用 “坍縮” 一詞僅是方便表述。</p>
</dd>
<dt class="label" id="f2"><span class="brackets"><a class="fn-backref" href="#id6">3</a></span></dt>
<dd><p>其實更常見的基礎二元量子閘是 “量子受控反閘”（CNOT）和 “量子交換閘”（SWAP）。</p>
</dd>
<dt class="label" id="f3"><span class="brackets"><a class="fn-backref" href="#id7">4</a></span></dt>
<dd><p>這種矩陣被稱之為 “么正矩陣” 或 “酉矩陣”。</p>
</dd>
</dl>
<script>
    $(document).ready(function(){
        $(".rst-footer-buttons").after("<div id='discourse-comments'></div>");
        DiscourseEmbed = { discourseUrl: 'https://discuss.tf.wiki/', topicId: 201 };
        (function() {
            var d = document.createElement('script'); d.type = 'text/javascript'; d.async = true;
            d.src = DiscourseEmbed.discourseUrl + 'javascripts/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(d);
        })();
    });
</script></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="rl.html" class="btn btn-neutral float-right" title="強化學習簡介" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="swift.html" class="btn btn-neutral float-left" title="Swift for TensorFlow (S4TF) (Huan）" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018-2021, Xihan Li (snowkylin)

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.

  <p><a href="https://beian.miit.gov.cn/" target="_blank">沪ICP备13038357号-18</a ></p> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-40509304-12', 'auto');
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>